<!DOCTYPE html>
<html><head><meta charset="utf-8"><title>Counted Deaths Report</title>
    <style>
      :root {
        --bg:#0b0e14; --panel:#11151d; --panel2:#0f1420; --border:#1f2937;
        --text:#e5e7eb; --muted:#9aa4b2; --link:#93c5fd; --linkhover:#bfdbfe;
        --goodbg:#063f2e; --good:#34d399; --goodbrd:#065f46;
        --badbg:#3b0d0d; --bad:#f87171; --badbrd:#7f1d1d;
        --bossh:#141a29; --totals:#3a2f0a; --totalsbrd:#b45309; --chip:#1f2937; --chipbrd:#374151;
        --outlier:#dc2626; --outlierbg:#450a0a;
      }
      body.light {
        --bg:#fff; --panel:#f9fafb; --panel2:#fff; --border:#e5e7eb; --text:#111827; --muted:#6b7280;
        --link:#1d4ed8; --linkhover:#1e40af; --goodbg:#e6ffed; --good:#047857; --goodbrd:#a7f3d0;
        --badbg:#fee2e2; --bad:#991b1b; --badbrd:#fecaca; --bossh:#eef2ff; --totals:#fef3c7; --totalsbrd:#f59e0b; --chip:#e5e7eb; --chipbrd:#d1d5db;
        --outlier:#dc2626; --outlierbg:#fef2f2;
      }
      html,body{margin:0;padding:0}
      body{background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;line-height:1.5;padding:24px}
      .wrap{max-width:1100px;margin:0 auto}
      h1{margin:0 0 8px}
      .topbar{display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap;margin-bottom:10px}
      .sub{color:var(--muted);margin:6px 0 12px}
      .toggle,.select{background:var(--panel);border:1px solid var(--border);color:var(--text);padding:6px 10px;border-radius:8px}
      .toggle{cursor:pointer}
      details{margin-bottom:12px;border:1px solid var(--border);border-radius:10px;padding:8px 12px;background:var(--panel)}
      summary{font-weight:600;cursor:pointer}
      table{width:100%;border-collapse:collapse;margin-top:8px}
      th,td{border-bottom:1px solid var(--border);padding:8px 10px;text-align:left}
      th{background:var(--panel2);position:sticky;top:0}
      .pill{display:inline-block;padding:2px 8px;border-radius:999px;font-size:12px;font-weight:600;border:1px solid}
      .kill{background:var(--goodbg);color:var(--good);border-color:var(--goodbrd)}
      .wipe{background:var(--badbg);color:var(--bad);border-color:var(--badbrd)}
      .outlier-badge{background:var(--outlierbg);color:var(--outlier);font-size:11px;padding:2px 6px;border-radius:4px;font-weight:700;margin-left:6px}
      .muted{color:var(--muted)}
      .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
      .bossh{background:var(--bossh);font-weight:600}
      .totals{background:var(--totals);border-top:1px solid var(--totalsbrd);font-weight:700}
      .chips{display:flex;gap:6px;flex-wrap:wrap}
      .chip{background:var(--chip);border:1px solid var(--chipbrd);padding:4px 8px;border-radius:999px;cursor:pointer;user-select:none}
      .chip.sel{outline:2px solid var(--link)}
      .search-box{background:var(--panel);border:1px solid var(--border);color:var(--text);padding:6px 10px;border-radius:8px;min-width:200px}
      .shame-section{background:var(--badbg);border:2px solid var(--badbrd);border-radius:10px;padding:12px;margin-bottom:16px}
      .shame-title{color:var(--bad);font-weight:700;font-size:16px;margin-bottom:8px}
      .shame-item{background:var(--panel);border:1px solid var(--border);border-radius:6px;padding:8px;margin-bottom:6px}
      .ability-table{font-size:13px;margin:8px 0}
      .ability-table td{padding:4px 8px}
      a{color:var(--link);text-decoration:none} a:hover{color:var(--linkhover);text-decoration:underline}
    </style>
    <script>
      const state = { data:null, cutoff:2, theme:null, selectedBosses:new Set(), searchQuery:'' };

      function fmt(ts){ try{ const d=new Date(ts); return isFinite(d)? d.toISOString().replace('T',' ').slice(0,19) : 'â€”'; }catch(e){return 'â€”'} }

      function bossPass(name){ return !state.selectedBosses.size || state.selectedBosses.has(name); }
      function playerMatchesSearch(name){ return !state.searchQuery || name.toLowerCase().includes(state.searchQuery.toLowerCase()); }
      function median(values){ if(!values.length) return 0; values=[...values].sort((a,b)=>a-b); const mid=Math.floor(values.length/2); return values.length%2?values[mid]:(values[mid-1]+values[mid])/2; }
      
      function buildChips(){
        const holder = document.getElementById('bossChips'); if(!holder) return;
        holder.innerHTML='';
        const bosses = Object.keys(state.data.bossParticipation||{}).sort((a,b)=>a.localeCompare(b));
        bosses.forEach(b=>{
          const el=document.createElement('span'); 
          el.className='chip' + (state.selectedBosses.has(b) ? ' sel' : ''); 
          el.textContent=b;
          el.onclick=()=>{ 
            if(state.selectedBosses.has(b)) state.selectedBosses.delete(b); 
            else state.selectedBosses.add(b); 
            buildChips();
            buildHallOfShame();
            buildPlayerList(); 
          };
          holder.appendChild(el);
        });
      }
      
      function buildHallOfShame(){
        const holder = document.getElementById('hallOfShame');
        if (!holder) return;
        
        const cutoff = state.cutoff;
        const eventsAll = state.data.events;
        
        // Group deaths by pull (reportId_fightId)
        const pullDeaths = {};
        for (const player of Object.keys(eventsAll)) {
          for (const ev of eventsAll[player]) {
            if (ev.rankWithinPull > cutoff || !bossPass(ev.boss)) continue;
            const pullKey = `${ev.reportId}_${ev.fightId}`;
            if (!pullDeaths[pullKey]) {
              pullDeaths[pullKey] = {
                reportId: ev.reportId,
                fightId: ev.fightId,
                boss: ev.boss,
                pullNo: ev.pullNo,
                isKill: ev.isKill,
                deaths: []
              };
            }
            pullDeaths[pullKey].deaths.push({player: ev.player, rank: ev.rankWithinPull, ability: ev.abilityName});
          }
        }
        
        // Sort by death count
        const sorted = Object.values(pullDeaths).sort((a,b) => b.deaths.length - a.deaths.length).slice(0,5);
        
        if (sorted.length === 0) {
          holder.style.display = 'none';
          return;
        }
        
        holder.style.display = 'block';
        holder.innerHTML = '<div class="shame-title">ðŸ”¥ Hall of Shame - Worst Pulls</div>';
        
        sorted.forEach((pull,idx) => {
          const pill = pull.isKill ? "<span class='pill kill'>KILL</span>" : "<span class='pill wipe'>wipe</span>";
          const link = `https://www.warcraftlogs.com/reports/${pull.reportId}?fight=${pull.fightId}&type=deaths`;
          const item = document.createElement('div');
          item.className = 'shame-item';
          item.innerHTML = `
            <strong>#${idx+1}</strong> ${pull.boss} Pull ${pull.pullNo} ${pill} - <strong>${pull.deaths.length}</strong> counted deaths
            <br><span class='muted'>${pull.deaths.map(d => d.player).join(', ')}</span>
            <br><a href="${link}" target="_blank" rel="noopener">View Report â†’</a>
          `;
          holder.appendChild(item);
        });
      }
      
      function buildPlayerList(){
        const wrap = document.getElementById('content');
        wrap.innerHTML = '';
        const cutoff = state.cutoff;
        const eventsAll = state.data.events;
        const pullsMap = state.data.pullParticipation;
        const bossPart = state.data.bossParticipation;

        // compute per-player stats for this cutoff
        const stats = [];
        for (const player of Object.keys(eventsAll)){
          const evs = eventsAll[player].filter(ev => ev.rankWithinPull <= cutoff && bossPass(ev.boss));
          if (!evs.length) continue;
          
          // Calculate pulls based on selected bosses
          let pulls;
          if (state.selectedBosses.size === 0) {
            // No filter - use all pulls
            pulls = (pullsMap[player]||[]).length;
          } else {
            // Count pulls only for selected bosses
            pulls = 0;
            for (const boss of state.selectedBosses) {
              if (bossPart[boss] && bossPart[boss][player]) {
                pulls += bossPart[boss][player].length;
              }
            }
          }
          
          const rate = pulls>0 ? (evs.length/pulls*100) : 0;
          stats.push([player, evs.length, pulls, rate]);
        }
        stats.sort((a,b)=> b[3]-a[3] || b[1]-a[1] || a[0].localeCompare(b[0]));

        if (!stats.length){
          wrap.innerHTML = "<p class='muted'>No counted deaths found.</p>";
          return;
        }

        // Calculate outliers per boss
        const outliersByBoss = {};
        for (const boss of Object.keys(bossPart)) {
          if (!bossPass(boss)) continue;
          const rates = [];
          for (const player of Object.keys(bossPart[boss])) {
            const bossPulls = bossPart[boss][player].length;
            const bossDeaths = (eventsAll[player] || []).filter(ev => ev.boss === boss && ev.rankWithinPull <= cutoff).length;
            if (bossPulls > 0) {
              rates.push(bossDeaths / bossPulls * 100);
            }
          }
          const medRate = median(rates);
          const threshold = medRate * 1.5;
          
          outliersByBoss[boss] = new Set();
          for (const player of Object.keys(bossPart[boss])) {
            const bossPulls = bossPart[boss][player].length;
            const bossDeaths = (eventsAll[player] || []).filter(ev => ev.boss === boss && ev.rankWithinPull <= cutoff).length;
            const playerRate = bossPulls > 0 ? (bossDeaths / bossPulls * 100) : 0;
            if (playerRate > threshold && playerRate > 0) {
              outliersByBoss[boss].add(player);
            }
          }
        }

        for (const [player,totalCounted,totalPulls,rate] of stats){
          if (!playerMatchesSearch(player)) continue; // Search filter
          
          const details = document.createElement('details');
          const summary = document.createElement('summary');
          summary.innerHTML = `${player} â€” <span class='muted'>${totalCounted} counted death(s) / ${totalPulls} pulls</span> <span class='rate'>Â· ${rate.toFixed(1)}%</span>`;
          details.appendChild(summary);
          
          details.addEventListener('toggle', () => {
            if (!details.open || details.dataset.built) return;
            details.dataset.built = '1';
            const table = document.createElement('table');
            table.innerHTML = "<thead><tr><th>Boss</th><th>Pull #</th><th>Outcome</th><th>Phase</th><th>Date/Time</th><th>Report</th><th>Rank</th></tr></thead><tbody></tbody>";
            const tbody = table.querySelector('tbody');

            const rows = (eventsAll[player].filter(ev => ev.rankWithinPull<=cutoff))
              .sort((a,b)=> (a.absTs-b.absTs) || (a.pullNo-b.pullNo));
            const byBoss = {};
            for (const ev of rows){ (byBoss[ev.boss] ||= []).push(ev); }

            for (const boss of Object.keys(byBoss).sort((a,b)=> a.localeCompare(b))){
              if (!bossPass(boss)) continue;
              const bossRows = byBoss[boss];
              const bossPulls = new Set((bossPart[boss] && bossPart[boss][player]) || []).size;
              const bossDeaths = bossRows.length;
              const bossRate = bossPulls>0 ? (bossDeaths/bossPulls*100) : 0;
              
              const isOutlier = outliersByBoss[boss] && outliersByBoss[boss].has(player);
              const outlierBadge = isOutlier ? '<span class="outlier-badge">OUTLIER</span>' : '';
              
              const trH = document.createElement('tr');
              trH.className = 'bossh';
              trH.innerHTML = `<td colspan="7">${boss} â€” ${bossDeaths} counted death(s) / ${bossPulls} pulls Â· <span class='rate'>${bossRate.toFixed(1)}%</span>${outlierBadge}</td>`;
              tbody.appendChild(trH);

              for (const ev of bossRows){
                const tr = document.createElement('tr');
                const link = `https://www.warcraftlogs.com/reports/${ev.reportId}?fight=${ev.fightId}&type=deaths&cutoff=${cutoff}`;
                const pill = ev.isKill ? "<span class='pill kill'>KILL</span>" : "<span class='pill wipe'>wipe</span>";
                tr.innerHTML = `<td>${boss}</td><td>${ev.pullNo}</td><td>${pill}</td><td>${ev.phase}</td><td class='mono'>${fmt(ev.absTs)}</td><td><a target="_blank" rel="noopener" href="${link}">${ev.reportId}<span class='muted'>#${ev.fightId}</span></a></td><td>${ev.rankWithinPull}</td>`;
                tbody.appendChild(tr);
              }
            }

            const trT = document.createElement('tr');
            trT.className = 'totals';
            trT.innerHTML = `<td colspan="7">Player total: ${totalCounted} counted death(s) / ${totalPulls} pulls Â· <span class='rate'>${rate.toFixed(1)}%</span></td>`;
            tbody.appendChild(trT);
            details.appendChild(table);
          }, {once:true});

          wrap.appendChild(details);
        }
      }

      async function bootstrap(){
        const urlCo = (location.hash.match(/co=(\d+)/)||[])[1];
        const saved = localStorage.getItem('raidReportCutoff');
        state.cutoff = parseInt(urlCo || saved || '2', 10);

        const res = await fetch('data.json', {cache:'no-store'});
        state.data = await res.json();

        document.getElementById('meta').innerHTML =
          `Authors: ${(state.data.meta.authorFilters||[]).join('; ') || 'All'} Â· Date â‰¤ ${state.data.meta.dateCutoff} Â· Zone=${state.data.meta.zone} Â· Diff=${state.data.meta.difficulty} Â· Generated ${state.data.meta.generatedAt}`;

        const select = document.getElementById('cutoffSelect');
        for (let i=1;i<=state.data.meta.maxCutoff;i++){
          const opt=document.createElement('option'); 
          opt.value=i; 
          opt.textContent = i===1 ? '1 Death' : `${i} Deaths`;
          if (i===state.cutoff) opt.selected=true; 
          select.appendChild(opt);
        }
        select.onchange = e => { 
          state.cutoff = parseInt(e.target.value,10); 
          localStorage.setItem('raidReportCutoff', String(state.cutoff)); 
          history.replaceState(null,'',`#co=${state.cutoff}`); 
          buildHallOfShame();
          buildPlayerList(); 
        };

        // Search box
        const searchBox = document.getElementById('searchBox');
        searchBox.oninput = e => {
          state.searchQuery = e.target.value;
          buildPlayerList();
        };

        buildChips();
        buildHallOfShame();
        buildPlayerList();
      }
      window.addEventListener('DOMContentLoaded', bootstrap);
    </script>
    </head>
<body>
  <div class="wrap">
    <div class="topbar">
      <h1>Counted Deaths Report</h1>
      <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
        <div id="bossChips" class="chips"></div>
        <input type="text" id="searchBox" class="search-box" placeholder="Search players...">
        <label for="cutoffSelect" class="muted">Deaths:</label>
        <select id="cutoffSelect" class="select"></select>
      </div>
    </div>
    <div id="meta" class="sub"></div>
    <div id="hallOfShame" class="shame-section"></div>
    <div id="content"></div>
  </div>
</body></html>
