<!DOCTYPE html>
<html><head><meta charset="utf-8"><title>Counted Deaths Report</title>
    <style>
      :root {
        --bg:#0b0e14; --panel:#11151d; --panel2:#0f1420; --border:#1f2937;
        --text:#e5e7eb; --muted:#9aa4b2; --link:#93c5fd; --linkhover:#bfdbfe;
        --goodbg:#063f2e; --good:#34d399; --goodbrd:#065f46;
        --badbg:#3b0d0d; --bad:#f87171; --badbrd:#7f1d1d;
        --bossh:#141a29; --totals:#3a2f0a; --totalsbrd:#b45309; --chip:#1f2937; --chipbrd:#374151;
      }
      body.light {
        --bg:#fff; --panel:#f9fafb; --panel2:#fff; --border:#e5e7eb; --text:#111827; --muted:#6b7280;
        --link:#1d4ed8; --linkhover:#1e40af; --goodbg:#e6ffed; --good:#047857; --goodbrd:#a7f3d0;
        --badbg:#fee2e2; --bad:#991b1b; --badbrd:#fecaca; --bossh:#eef2ff; --totals:#fef3c7; --totalsbrd:#f59e0b; --chip:#e5e7eb; --chipbrd:#d1d5db;
      }
      html,body{margin:0;padding:0}
      body{background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;line-height:1.5;padding:24px}
      .wrap{max-width:1100px;margin:0 auto}
      h1{margin:0 0 8px}
      .topbar{display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap;margin-bottom:10px}
      .sub{color:var(--muted);margin:6px 0 12px}
      .toggle,.select{background:var(--panel);border:1px solid var(--border);color:var(--text);padding:6px 10px;border-radius:8px}
      .toggle{cursor:pointer}
      details{margin-bottom:12px;border:1px solid var(--border);border-radius:10px;padding:8px 12px;background:var(--panel)}
      summary{font-weight:600;cursor:pointer}
      table{width:100%;border-collapse:collapse;margin-top:8px}
      th,td{border-bottom:1px solid var(--border);padding:8px 10px;text-align:left}
      th{background:var(--panel2);position:sticky;top:0}
      .pill{display:inline-block;padding:2px 8px;border-radius:999px;font-size:12px;font-weight:600;border:1px solid}
      .kill{background:var(--goodbg);color:var(--good);border-color:var(--goodbrd)}
      .wipe{background:var(--badbg);color:var(--bad);border-color:var(--badbrd)}
      .muted{color:var(--muted)}
      .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
      .bossh{background:var(--bossh);font-weight:600}
      .totals{background:var(--totals);border-top:1px solid var(--totalsbrd);font-weight:700}
      .chips{display:flex;gap:6px;flex-wrap:wrap}
      .chip{background:var(--chip);border:1px solid var(--chipbrd);padding:4px 8px;border-radius:999px;cursor:pointer;user-select:none}
      .chip.sel{outline:2px solid var(--link)}
      .search-box{background:var(--panel);border:1px solid var(--border);color:var(--text);padding:6px 10px;border-radius:8px;min-width:200px}
      .overview-table{margin-bottom:20px}
      .overview-table table{font-size:13px}
      .overview-table th{cursor:pointer;user-select:none}
      .overview-table th:hover{background:var(--border)}
      .rate-cell{text-align:center;font-weight:600}
      a{color:var(--link);text-decoration:none} a:hover{color:var(--linkhover);text-decoration:underline}
    </style>
    <script>
      const state = { data:null, cutoff:2, theme:null, selectedBosses:new Set(), searchQuery:'' };

      function fmt(ts){ try{ const d=new Date(ts); return isFinite(d)? d.toISOString().replace('T',' ').slice(0,19) : 'â€”'; }catch(e){return 'â€”'} }

      function bossPass(name){ return !state.selectedBosses.size || state.selectedBosses.has(name); }
      function playerMatchesSearch(name){ return !state.searchQuery || name.toLowerCase().includes(state.searchQuery.toLowerCase()); }
      function median(values){ if(!values.length) return 0; values=[...values].sort((a,b)=>a-b); const mid=Math.floor(values.length/2); return values.length%2?values[mid]:(values[mid-1]+values[mid])/2; }
      
      function hasAlts(player) {
        const charGroups = state.data.meta.characterGroups || {};
        return charGroups[player] && charGroups[player].length > 0;
      }
      
      function getPlayerAlts(player) {
        const charGroups = state.data.meta.characterGroups || {};
        return charGroups[player] || [];
      }
      
      function buildChips(){
        const holder = document.getElementById('bossChips'); if(!holder) return;
        holder.innerHTML='';
        const bosses = Object.keys(state.data.bossParticipation||{}).sort((a,b)=>a.localeCompare(b));
        bosses.forEach(b=>{
          const el=document.createElement('span'); 
          el.className='chip' + (state.selectedBosses.has(b) ? ' sel' : ''); 
          el.textContent=b;
          el.onclick=()=>{ 
            if(state.selectedBosses.has(b)) state.selectedBosses.delete(b); 
            else state.selectedBosses.add(b); 
            buildChips();
            buildPlayerList(); 
          };
          holder.appendChild(el);
        });
      }
      
      function buildOverviewTable(){
        const holder = document.getElementById('overviewTable');
        if (!holder) return;
        
        const cutoff = state.cutoff;
        const eventsAll = state.data.events;
        const bossPart = state.data.bossParticipation;
        const pullsMap = state.data.pullParticipation;
        
        const bosses = Object.keys(bossPart).sort((a,b)=>a.localeCompare(b));
        const players = Object.keys(eventsAll).sort();
        
        if (!players.length) {
          holder.style.display = 'none';
          return;
        }
        
        holder.style.display = 'block';
        const table = document.createElement('table');
        const thead = document.createElement('thead');
        const headerRow = document.createElement('tr');
        headerRow.innerHTML = '<th>Player</th>' + bosses.map(b => `<th>${b}</th>`).join('') + '<th>Overall</th>';
        thead.appendChild(headerRow);
        table.appendChild(thead);
        
        const tbody = document.createElement('tbody');
        players.forEach(player => {
          const tr = document.createElement('tr');
          const playerCell = document.createElement('td');
          playerCell.innerHTML = `<strong>${player}</strong>`;
          tr.appendChild(playerCell);
          
          bosses.forEach(boss => {
            const td = document.createElement('td');
            td.className = 'rate-cell';
            const bossPulls = (bossPart[boss] && bossPart[boss][player]) ? bossPart[boss][player].length : 0;
            const bossDeaths = (eventsAll[player] || []).filter(ev => ev.boss === boss && ev.rankWithinPull <= cutoff).length;
            const rate = bossPulls > 0 ? (bossDeaths / bossPulls * 100) : 0;
            
            if (bossPulls === 0) {
              td.textContent = 'â€”';
              td.style.opacity = '0.4';
            } else {
              td.textContent = rate.toFixed(1) + '%';
            }
            tr.appendChild(td);
          });
          
          // Overall column
          const overallTd = document.createElement('td');
          overallTd.className = 'rate-cell';
          const totalPulls = (pullsMap[player] || []).length;
          const totalDeaths = (eventsAll[player] || []).filter(ev => ev.rankWithinPull <= cutoff).length;
          const overallRate = totalPulls > 0 ? (totalDeaths / totalPulls * 100) : 0;
          overallTd.innerHTML = `<strong>${overallRate.toFixed(1)}%</strong>`;
          tr.appendChild(overallTd);
          
          tbody.appendChild(tr);
        });
        table.appendChild(tbody);
        
        holder.innerHTML = '';
        holder.appendChild(table);
        
        // Make sortable
        const headers = thead.querySelectorAll('th');
        headers.forEach((th, idx) => {
          th.onclick = () => {
            const rows = Array.from(tbody.querySelectorAll('tr'));
            rows.sort((a, b) => {
              const aCell = a.cells[idx].textContent;
              const bCell = b.cells[idx].textContent;
              if (idx === 0) return aCell.localeCompare(bCell); // Name
              const aVal = parseFloat(aCell) || 0;
              const bVal = parseFloat(bCell) || 0;
              return bVal - aVal; // Descending for rates
            });
            rows.forEach(row => tbody.appendChild(row));
          };
        });
      }
      
      function buildPlayerList(){
        const wrap = document.getElementById('content');
        wrap.innerHTML = '';
        const cutoff = state.cutoff;
        const eventsAll = state.data.events;
        const pullsMap = state.data.pullParticipation;
        const bossPart = state.data.bossParticipation;
        const charBreakdown = state.data.characterBreakdown || {};

        // compute per-player stats for this cutoff
        const stats = [];
        for (const player of Object.keys(eventsAll)){
          const evs = eventsAll[player].filter(ev => ev.rankWithinPull <= cutoff && bossPass(ev.boss));
          if (!evs.length) continue;
          
          // Calculate pulls based on selected bosses
          let pulls;
          if (state.selectedBosses.size === 0) {
            // No filter - use all pulls
            pulls = (pullsMap[player]||[]).length;
          } else {
            // Count pulls only for selected bosses
            pulls = 0;
            for (const boss of state.selectedBosses) {
              if (bossPart[boss] && bossPart[boss][player]) {
                pulls += bossPart[boss][player].length;
              }
            }
          }
          
          const rate = pulls>0 ? (evs.length/pulls*100) : 0;
          stats.push([player, evs.length, pulls, rate]);
        }
        stats.sort((a,b)=> b[3]-a[3] || b[1]-a[1] || a[0].localeCompare(b[0]));

        if (!stats.length){
          wrap.innerHTML = "<p class='muted'>No counted deaths found.</p>";
          return;
        }

        for (const [player,totalCounted,totalPulls,rate] of stats){
          if (!playerMatchesSearch(player)) continue; // Search filter
          
          const details = document.createElement('details');
          const summary = document.createElement('summary');
          const altIndicator = hasAlts(player) ? ' <span class="muted">(grouped)</span>' : '';
          summary.innerHTML = `${player}${altIndicator} â€” <span class='muted'>${totalCounted} counted death(s) / ${totalPulls} pulls</span> <span class='rate'>Â· ${rate.toFixed(1)}%</span>`;
          details.appendChild(summary);
          
          details.addEventListener('toggle', () => {
            if (!details.open || details.dataset.built) return;
            details.dataset.built = '1';
            
            // If player has alts, show character breakdown first
            if (hasAlts(player)) {
              const charDetails = document.createElement('details');
              charDetails.style.marginBottom = '12px';
              charDetails.style.marginLeft = '16px';
              const charSummary = document.createElement('summary');
              charSummary.innerHTML = '<strong>ðŸ“Š Character Breakdown</strong>';
              charDetails.appendChild(charSummary);
              
              const charTable = document.createElement('table');
              charTable.style.fontSize = '13px';
              charTable.innerHTML = '<thead><tr><th>Character</th><th>Deaths</th><th>Rate</th></tr></thead><tbody></tbody>';
              const charTbody = charTable.querySelector('tbody');
              
              const chars = charBreakdown[player] || {};
              const alts = [player, ...getPlayerAlts(player)].filter(c => chars[c] && chars[c].length > 0);
              
              for (const char of alts) {
                // Skip if this character name matches the main name (prevents duplicates)
                if (char === player && getPlayerAlts(player).includes(player)) continue;
                
                const charEvs = (chars[char] || []).filter(ev => ev.rankWithinPull <= cutoff && bossPass(ev.boss));
                const charDeaths = charEvs.length;
                const charRate = totalPulls > 0 ? (charDeaths / totalPulls * 100) : 0;
                
                const tr = document.createElement('tr');
                tr.innerHTML = `<td><strong>${char}</strong></td><td>${charDeaths}</td><td>${charRate.toFixed(1)}%</td>`;
                charTbody.appendChild(tr);
              }
              
              charDetails.appendChild(charTable);
              details.appendChild(charDetails);
            }
            
            const table = document.createElement('table');
            table.innerHTML = "<thead><tr><th>Boss</th><th>Pull #</th><th>Outcome</th><th>Phase</th><th>Character</th><th>Killing Blow</th><th>Date/Time</th><th>Report</th><th>Rank</th></tr></thead><tbody></tbody>";
            const tbody = table.querySelector('tbody');

            const rows = (eventsAll[player].filter(ev => ev.rankWithinPull<=cutoff))
              .sort((a,b)=> (a.absTs-b.absTs) || (a.pullNo-b.pullNo));
            const byBoss = {};
            for (const ev of rows){ (byBoss[ev.boss] ||= []).push(ev); }

            for (const boss of Object.keys(byBoss).sort((a,b)=> a.localeCompare(b))){
              if (!bossPass(boss)) continue;
              const bossRows = byBoss[boss];
              const bossPulls = new Set((bossPart[boss] && bossPart[boss][player]) || []).size;
              const bossDeaths = bossRows.length;
              const bossRate = bossPulls>0 ? (bossDeaths/bossPulls*100) : 0;
              
              // Calculate improvement trend (early vs late pulls)
              let trendIndicator = '';
              if (bossPulls >= 10) {
                const sorted = bossRows.sort((a, b) => a.pullNo - b.pullNo);
                const midPoint = Math.ceil(sorted.length / 2);
                const earlyDeaths = sorted.slice(0, midPoint);
                const lateDeaths = sorted.slice(midPoint);
                
                const earlyPulls = Math.ceil(bossPulls / 2);
                const latePulls = bossPulls - earlyPulls;
                
                const earlyRate = earlyPulls > 0 ? (earlyDeaths.length / earlyPulls * 100) : 0;
                const lateRate = latePulls > 0 ? (lateDeaths.length / latePulls * 100) : 0;
                const improvement = earlyRate - lateRate;
                
                if (improvement > 5) {
                  trendIndicator = '<span style="color:#34d399;margin-left:8px;font-size:11px" title="Death rate improved by ' + improvement.toFixed(1) + '%">ðŸ“ˆ Improving</span>';
                }
              }
              
              // Count abilities for this boss
              const abilityCounts = {};
              for (const ev of bossRows) {
                const ability = ev.abilityName || 'Unknown';
                abilityCounts[ability] = (abilityCounts[ability] || 0) + 1;
              }
              const topAbilities = Object.entries(abilityCounts)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 5)
                .map(([name, count]) => `${name} (${count})`)
                .join(' Â· ');
              
              const trH = document.createElement('tr');
              trH.className = 'bossh';
              trH.innerHTML = `<td colspan="9">${boss} â€” ${bossDeaths} counted death(s) / ${bossPulls} pulls Â· <span class='rate'>${bossRate.toFixed(1)}%</span>${trendIndicator}<br><span class='muted' style='font-weight:normal;font-size:12px'>${topAbilities}</span></td>`;
              tbody.appendChild(trH);

              for (const ev of bossRows){
                const tr = document.createElement('tr');
                const link = `https://www.warcraftlogs.com/reports/${ev.reportId}?fight=${ev.fightId}&type=deaths&cutoff=${cutoff}`;
                const pill = ev.isKill ? "<span class='pill kill'>KILL</span>" : "<span class='pill wipe'>wipe</span>";
                const charName = ev.originalCharacter || ev.player;
                const charDisplay = charName !== player ? `<span class='muted'>${charName}</span>` : 'â€”';
                tr.innerHTML = `<td>${boss}</td><td>${ev.pullNo}</td><td>${pill}</td><td>${ev.phase}</td><td>${charDisplay}</td><td>${ev.abilityName}</td><td class='mono'>${fmt(ev.absTs)}</td><td><a target="_blank" rel="noopener" href="${link}">${ev.reportId}<span class='muted'>#${ev.fightId}</span></a></td><td>${ev.rankWithinPull}</td>`;
                tbody.appendChild(tr);
              }
            }

            const trT = document.createElement('tr');
            trT.className = 'totals';
            trT.innerHTML = `<td colspan="9">Player total: ${totalCounted} counted death(s) / ${totalPulls} pulls Â· <span class='rate'>${rate.toFixed(1)}%</span></td>`;
            tbody.appendChild(trT);
            details.appendChild(table);
          }, {once:true});

          wrap.appendChild(details);
        }
      }

      async function bootstrap(){
        const urlCo = (location.hash.match(/co=(\d+)/)||[])[1];
        const saved = localStorage.getItem('raidReportCutoff');
        state.cutoff = parseInt(urlCo || saved || '2', 10);

        const res = await fetch('data.json', {cache:'no-store'});
        state.data = await res.json();

        document.getElementById('meta').innerHTML =
          `Authors: ${(state.data.meta.authorFilters||[]).join('; ') || 'All'} Â· Date â‰¤ ${state.data.meta.dateCutoff} Â· Zone=${state.data.meta.zone} Â· Diff=${state.data.meta.difficulty} Â· Generated ${state.data.meta.generatedAt}`;

        const select = document.getElementById('cutoffSelect');
        for (let i=1;i<=state.data.meta.maxCutoff;i++){
          const opt=document.createElement('option'); 
          opt.value=i; 
          opt.textContent = i===1 ? '1 Death' : `${i} Deaths`;
          if (i===state.cutoff) opt.selected=true; 
          select.appendChild(opt);
        }
        select.onchange = e => { 
          state.cutoff = parseInt(e.target.value,10); 
          localStorage.setItem('raidReportCutoff', String(state.cutoff)); 
          history.replaceState(null,'',`#co=${state.cutoff}`); 
          buildOverviewTable();
          buildPlayerList(); 
        };

        // Search box
        const searchBox = document.getElementById('searchBox');
        searchBox.oninput = e => {
          state.searchQuery = e.target.value;
          buildPlayerList();
        };

        buildChips();
        buildOverviewTable();
        buildPlayerList();
      }
      window.addEventListener('DOMContentLoaded', bootstrap);
    </script>
    </head>
<body>
  <div class="wrap">
    <div class="topbar">
      <h1>Counted Deaths Report</h1>
      <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
        <div id="bossChips" class="chips"></div>
        <input type="text" id="searchBox" class="search-box" placeholder="Search players...">
        <label for="cutoffSelect" class="muted">Deaths:</label>
        <select id="cutoffSelect" class="select"></select>
      </div>
    </div>
    <div id="meta" class="sub"></div>
    <details class="overview-table">
      <summary style="font-weight:700;margin-bottom:12px">ðŸ“Š All Bosses Overview (click to expand)</summary>
      <div id="overviewTable"></div>
    </details>
    <div id="content"></div>
  </div>
</body></html>
