<!DOCTYPE html>
<html><head><meta charset="utf-8"><title>Counted Deaths Report</title>
    <style>
      :root {
        --bg:#0b0e14; --panel:#11151d; --panel2:#0f1420; --border:#1f2937;
        --text:#e5e7eb; --muted:#9aa4b2; --link:#93c5fd; --linkhover:#bfdbfe;
        --goodbg:#063f2e; --good:#34d399; --goodbrd:#065f46;
        --badbg:#3b0d0d; --bad:#f87171; --badbrd:#7f1d1d;
        --bossh:#141a29; --totals:#3a2f0a; --totalsbrd:#b45309; --chip:#1f2937; --chipbrd:#374151;
      }
      body.light {
        --bg:#fff; --panel:#f9fafb; --panel2:#fff; --border:#e5e7eb; --text:#111827; --muted:#6b7280;
        --link:#1d4ed8; --linkhover:#1e40af; --goodbg:#e6ffed; --good:#047857; --goodbrd:#a7f3d0;
        --badbg:#fee2e2; --bad:#991b1b; --badbrd:#fecaca; --bossh:#eef2ff; --totals:#fef3c7; --totalsbrd:#f59e0b; --chip:#e5e7eb; --chipbrd:#d1d5db;
      }
      html,body{margin:0;padding:0}
      body{background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;line-height:1.5;padding:24px}
      .wrap{max-width:1100px;margin:0 auto}
      h1{margin:0 0 8px}
      .topbar{display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap;margin-bottom:10px}
      .sub{color:var(--muted);margin:6px 0 12px}
      .toggle,.select{background:var(--panel);border:1px solid var(--border);color:var(--text);padding:6px 10px;border-radius:8px}
      .toggle{cursor:pointer}
      details{margin-bottom:12px;border:1px solid var(--border);border-radius:10px;padding:8px 12px;background:var(--panel)}
      summary{font-weight:600;cursor:pointer}
      table{width:100%;border-collapse:collapse;margin-top:8px}
      th,td{border-bottom:1px solid var(--border);padding:8px 10px;text-align:left}
      th{background:var(--panel2);position:sticky;top:0}
      .pill{display:inline-block;padding:2px 8px;border-radius:999px;font-size:12px;font-weight:600;border:1px solid}
      .kill{background:var(--goodbg);color:var(--good);border-color:var(--goodbrd)}
      .wipe{background:var(--badbg);color:var(--bad);border-color:var(--badbrd)}
      .muted{color:var(--muted)}
      .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
      .bossh{background:var(--bossh);font-weight:600}
      .totals{background:var(--totals);border-top:1px solid var(--totalsbrd);font-weight:700}
      a{color:var(--link);text-decoration:none} a:hover{color:var(--linkhover);text-decoration:underline}
    </style>
    <script>
  const state = { data:null, cutoff:2, theme:null, selectedBosses:new Set() };

  function setTheme(light){
    document.body.classList.toggle('light', !!light);
    localStorage.setItem('raidReportTheme', light ? 'light':'dark');
  }
  function initTheme(){
    const saved = localStorage.getItem('raidReportTheme');
    if (saved==='light') setTheme(true);
    else if (saved==='dark') setTheme(false);
    else if (window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches) setTheme(true);
  }
  function fmt(ts){ try{ const d=new Date(ts); return isFinite(d)? d.toISOString().replace('T',' ').slice(0,19) : '—'; }catch(e){return '—'} }
  function bossPass(name){ return state.selectedBosses.size===0 || state.selectedBosses.has(name); }
  function median(vals){ if(!vals.length) return 0; vals=[...vals].sort((a,b)=>a-b); const m=vals.length>>1; return vals.length%2?vals[m]:(vals[m-1]+vals[m])/2; }

  function buildChips(){
    const holder = document.getElementById('bossChips'); if(!holder) return;
    holder.innerHTML = '';
    const bosses = Object.keys(state.data?.bossParticipation||{}).sort((a,b)=>a.localeCompare(b));
    bosses.forEach(b=>{
      const el = document.createElement('span');
      el.className = 'chip';
      el.textContent = b;
      el.onclick = () => {
        if (state.selectedBosses.has(b)) state.selectedBosses.delete(b);
        else state.selectedBosses.add(b);
        el.classList.toggle('sel');
        buildPlayerList(); // re-rank/re-render
      };
      holder.appendChild(el);
    });
  }

  async function bootstrap(){
    initTheme();
    // cutoff restore
    const urlCo = (location.hash.match(/co=(\d+)/)||[])[1];
    const saved = localStorage.getItem('raidReportCutoff');
    state.cutoff = parseInt(urlCo || saved || '2', 10);

    const meta = document.getElementById('meta');
    const content = document.getElementById('content');

    try {
      const res = await fetch('data.json', {cache:'no-store'});
      if (!res.ok) throw new Error('HTTP '+res.status);
      state.data = await res.json();
      console.log('[raid-reports] data.json loaded', {
        players: Object.keys(state.data.events||{}).length,
        bosses: Object.keys(state.data.bossParticipation||{}).length
      });
    } catch (err) {
      console.error('Failed to load data.json', err);
      meta.textContent = '⚠️ Could not load data.json. Make sure it was uploaded next to index.html.';
      content.innerHTML = "<p class='muted'>Nothing to show because data.json failed to load.</p>";
      // still render the deaths dropdown so the page isn't blank
      const select = document.getElementById('cutoffSelect');
      for (let i=1;i<=5;i++){ const o=document.createElement('option'); o.value=i; o.textContent=i===1?'1 Death':i+' Deaths'; select.appendChild(o); }
      return;
    }

    meta.innerHTML =
      `Authors: ${(state.data.meta.authorFilters||[]).join('; ') || 'All'} · Date ≤ ${state.data.meta.dateCutoff} · ` +
      `Zone=${state.data.meta.zone} · Diff=${state.data.meta.difficulty} · Generated ${state.data.meta.generatedAt}`;

    const select = document.getElementById('cutoffSelect');
    select.innerHTML = '';
    for (let i=1;i<=state.data.meta.maxCutoff;i++){
      const opt=document.createElement('option');
      opt.value=i; opt.textContent = i===1 ? '1 Death' : `${i} Deaths`;
      if (i===state.cutoff) opt.selected=true;
      select.appendChild(opt);
    }
    select.onchange = e => {
      state.cutoff = parseInt(e.target.value,10);
      localStorage.setItem('raidReportCutoff', String(state.cutoff));
      history.replaceState(null,'',`#co=${state.cutoff}`);
      buildPlayerList();
    };

    buildChips();
    buildPlayerList();
  }
  window.addEventListener('DOMContentLoaded', bootstrap);

  // Rebuild the player list using current filters
  function buildPlayerList(){
    const wrap = document.getElementById('content');
    wrap.innerHTML = '';
    const cutoff = state.cutoff;
    const eventsAll = state.data?.events || {};
    const pullsMap = state.data?.pullParticipation || {};
    const bossPart = state.data?.bossParticipation || {};

    // compute per-player stats using selected bosses
    const stats = [];
    function pullsForPlayerFiltered(player){
      const set = new Set();
      const bosses = Object.keys(bossPart);
      for (const b of bosses){
        if (state.selectedBosses.size && !state.selectedBosses.has(b)) continue;
        const bp = bossPart[b] && bossPart[b][player];
        if (!bp) continue;
        for (const pid of bp) set.add(pid);
      }
      if (set.size===0 && state.selectedBosses.size===0){
        for (const pid of (pullsMap[player]||[])) set.add(pid);
      }
      return set.size;
    }

    for (const player of Object.keys(eventsAll)){
      const evs = eventsAll[player].filter(ev => ev.rankWithinPull <= cutoff && (state.selectedBosses.size===0 || state.selectedBosses.has(ev.boss)));
      if (!evs.length) continue;
      const pulls = pullsForPlayerFiltered(player);
      const rate = pulls>0 ? (evs.length/pulls*100) : 0;
      stats.push([player, evs.length, pulls, rate]);
    }
    stats.sort((a,b)=> b[3]-a[3] || b[1]-a[1] || a[0].localeCompare(b[0]));

    if (!stats.length){
      wrap.innerHTML = "<p class='muted'>No counted deaths found for the current filters.</p>";
      return;
    }

    // Build each player's collapsible section (uses your existing markup)
    stats.forEach(([player,totalCounted,totalPulls,rate]) => {
      const details = document.createElement('details');
      const summary = document.createElement('summary');
      summary.innerHTML = `${player} — <span class='muted'>${totalCounted} counted death(s) / ${totalPulls} pulls</span> <span class='rate'>· ${rate.toFixed(1)}%</span>`;
      details.appendChild(summary);

      details.addEventListener('toggle', () => {
        if (!details.open || details.dataset.built) return;
        details.dataset.built = '1';
        const table = document.createElement('table');
        table.innerHTML = "<thead><tr><th>Boss</th><th>Pull #</th><th>Outcome</th><th>Phase</th><th>Date/Time</th><th>Killing Blow</th><th>Report</th><th>Rank</th></tr></thead><tbody></tbody>";
        const tbody = table.querySelector('tbody');

        const rows = (eventsAll[player].filter(ev => ev.rankWithinPull<=cutoff && (state.selectedBosses.size===0 || state.selectedBosses.has(ev.boss))))
          .sort((a,b)=> (a.absTs-b.absTs) || (a.pullNo-b.pullNo));
        const byBoss = {};
        for (const ev of rows){ (byBoss[ev.boss] ||= []).push(ev); }

        for (const boss of Object.keys(byBoss).sort((a,b)=> a.localeCompare(b))){
          if (!bossPass(boss)) continue;
          const bossRows = byBoss[boss];
          const bossPulls = new Set((bossPart[boss] && bossPart[boss][player]) || []).size;
          const bossDeaths = bossRows.length;

          // team median outlier calc
          const teamRates=[];
          for(const pl of Object.keys(eventsAll)){
            const pPulls = ((bossPart[boss] && bossPart[boss][pl])? new Set(bossPart[boss][pl]).size : 0);
            const pDeaths = (eventsAll[pl]||[]).filter(ev=>ev.rankWithinPull<=cutoff && ev.boss===boss).length;
            if(pPulls>0) teamRates.push(pDeaths/pPulls);
          }
          const med = median(teamRates);
          const rate = bossPulls>0 ? (bossDeaths/bossPulls) : 0;
          const isOut = (rate > 1.5*med) && bossPulls >= 2;

          const trH = document.createElement('tr');
          trH.className = 'bossh';
          trH.innerHTML = `<td colspan="8">${boss} — ${bossDeaths} counted death(s) / ${bossPulls} pulls · <span class='rate'>${(rate*100).toFixed(1)}%</span>`
            + (isOut? ` <span class='pill outlier'>outlier</span>` : '') + `</td>`;
          tbody.appendChild(trH);

          for (const ev of bossRows){
            const tr = document.createElement('tr');
            const link = `https://www.warcraftlogs.com/reports/${ev.reportId}?fight=${ev.fightId}&type=deaths&cutoff=${cutoff}`;
            const pill = ev.isKill ? "<span class='pill kill'>KILL</span>" : "<span class='pill wipe'>wipe</span>";
            tr.innerHTML = `<td>${boss}</td><td>${ev.pullNo}</td><td>${pill}</td><td>${ev.phase}</td><td class='mono'>${fmt(ev.absTs)}</td><td>${ev.abilityName||'Unknown'}</td><td><a target="_blank" rel="noopener" href="${link}">${ev.reportId}<span class='muted'>#${ev.fightId}</span></a></td><td>${ev.rankWithinPull}</td>`;
            tbody.appendChild(tr);
          }

          const trT = document.createElement('tr');
          trT.className = 'totals';
          trT.innerHTML = `<td colspan="8">Player total (filtered): ${totalCounted} counted death(s) / ${totalPulls} pulls · <span class='rate'>${rate.toFixed(1)}%</span></td>`;
          tbody.appendChild(trT);
        }

        details.appendChild(table);
      }, {once:true});

      wrap.appendChild(details);
    });
  }
</script>
    </head>
<body>
  <div class="wrap">
    <div class="topbar">
      <h1>Counted Deaths Report</h1>
      <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
        <button id="toggle" class="toggle">Toggle Light/Dark</button>
        <label for="cutoffSelect" class="muted">Deaths:</label>
        <select id="cutoffSelect" class="select"></select>
      </div>
    </div>
    <div id="meta" class="sub"></div>
    <div id="content"></div>
  </div>
</body></html>
